Q:thread_switch只需要保存/还原被调用方保存的寄存器的原因是什么？
A:这里仅需保存被调用者保存(callee-save)寄存器的原因和 xv6 中内核线程切换时仅保留 callee-save 寄存器的原因是相同的. 由于 thread_switch() 一定由其所在的 C 语言函数调用, 因此函数的调用规则是满足 xv6 的函数调用规则的, 对于其它 caller-save 寄存器都会被保存在线程的堆栈上, 在切换后的线程上下文恢复时可以直接从切换后线程的堆栈上恢复 caller-save 寄存器的值. 由于 callee-save 寄存器是由被调用函数即 thread_switch() 进行保存的, 在函数返回时已经丢失, 因此需要额外保存这些寄存器的内容.

Q:为什么两个线程都丢失了键，而不是一个线程？确定可能导致键丢失的具有2个线程的事件序列。
A:线程A将链表头更新为a，线程B将链表头更新为b，A和B同时进行，导师有一个头节点丢失。
