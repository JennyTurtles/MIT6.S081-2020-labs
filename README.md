# lab5:Xv6 Lazy Page Allocation
### 开始日期：2023.01.09
### 完成日期：2023.01.11
- ### `心得`
  - 本次实验需要基于page fault实现lazy allocation，即：应用程序向系统请求堆内存空间时，系统延迟分配堆内存。这样做有两个好处，一是当程序一次性请求大量内存时，能够迅速地完成；二是程序申请分配的空间往往大于实际使用的空间，lazy allocation只在内存被实际用到的时候才进行内存分配，因此可以在一定程度上节约内存空间。
- ### `任务1 修改内存分配方式`
  - 原内存分配方式：使用sbrk(n)，n为新增/减少的内存字节数，sbrk首先会修改进程的sz（内存大小），然后调用growproc为虚拟内存分配物理空间并进行映射。
  - 要实现lazy allocation首先需要将growproc删除，阻止sbrk直接进行内存分配，正确的内存分配时刻应该为触发缺页异常时。
- ### `任务2 实现内存懒分配`
  - 由于在sbrk里没有为程序分配物理内存，当程序试图读写内存时，就会触发page fault并进入内核中的usertrap()。
  - 要想在usertrap中处理page fault并为正确的地址分配物理内存，必须要获取出错的虚拟内存地址和触发trap的原因。这两者可以分别从STVAL寄存器和SCAUSE寄存器获取，page fault对应的SCAUSE编号是13和15（读和写）。
  - 当SCAUSE编号为13和15时，进一步判断待分配的虚拟地址是否落在进程的用户栈内，该地址必须小于p->sz且大于p->trapframe->sp（sp指向栈的最底部）。
  - 满足以上条件即可为虚拟内存分配一个page的物理地址，分配完之后使用mappages()建立他们之间的映射。
  - 以上步骤初步完成了内存懒分配。
- ### `任务3 完善内存懒分配`
  - 内存懒分配会带来一系列问题，以下将一一进行处理。
  - uvmunmap：程序释放内存时默认所有内存都进行了分配（都映射到了物理地址），然而使用了懒分配以后，会有一部分尚未被使用的内存未被映射到物理地址。在释放内存的过程中，程序无法找到它们的页表，因此会触发panic。解决方法是直接删除panic让程序继续运行即可。
  - uvmcopy：fork()会把父进程的内存拷贝到子进程，拷贝的过程中uvmcopy会遍历父进程的页表，这时就会出现上文一样的问题：无法找到内存的映射，触发panic，处理方法也同上文：直接删除panic。
  - walkaddr：read()和write()同样涉及到内存的调用，然而与前面不同的是，它们是系统调用，是在内核态中运行的，内核态中无法触发page fault，因此read()和write()访问内存失败时无法进入usertrap分配新的内存。进一步分析，read()和write()会分别调用copyin()和copyout()，这两者都会使用walkaddr()查询物理地址，因此解决方法是在walkaddr内分配新的内存并建立映射，这与usertrap中的方法是类似的。

- ### `完成！`
![Image text]
