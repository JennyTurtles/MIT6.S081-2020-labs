# lab3:page tables
### 开始日期：2022.12.27
### 完成日期：2023.01.01

- ### `心得`
- 实验目的：
  - 在用户空间，xv6会分别为每个进程提供单独的用户页表；然而在内核中，所有进程都会共享一个唯一的内核页表。每个进程的用户页表和内核页表是不同的，这样可以防止程序在用户空间修改内核数据，有利于保证隔离性。
  - 然而这种隔离策略也会给内核访问用户数据带来困难，内核接收到用户空间的虚拟地址之后，必须调用walk()，通过遍历三级页表获取对应的物理地址，然后将才能把数据传送到用户空间。
  - 使用walk()相比与直接解引用地址，不仅代码实现更复杂，运行速度也会更慢（无法利用硬件内的TLB进行快速映射）。
  - lab3的任务便是实现内核中直接解引用访问用户数据。
- ### `任务1 打印页表` 
  - 编写vmprint()，vmprint()接受一个页表，并输出页表内各级的PTE，将页表可视化对后续的调试有帮助。这题比较简单，模仿freewalk()对页表进行递归即可获取每级的PTE。需要注意的是PTE的前10位是flags，去掉flags后剩下的44位再在低位加上12位0（地址的格式需要对齐），即可得到下一级的物理地址了。
- ### `任务2 各进程内核页表隔离` 
  - 分析：要使内核能够直接解引用用户数据，直接让内核使用用户页表显然是没有用的，那么就需要在内核页表内重新建立用户页表上的映射，用户空间的虚拟地址范围为0～PLIC，内核从PLIC开始，只要保证用户空间的虚拟地址不超过PLIC就不会发生重复映射。在重新建立映射之前，首先需要实现各进程的内核页表隔离（xv6内核中所有进程共享唯一内核页表，建立新映射后无法实现隔离性）。
  - 首先需要为每个进程创建新的内核页表，页表跟进程是一一绑定的，因此显然要在proc结构体内新增一个字段用于存储新的专属内核页表。
  - 进程生成时，页表和内核栈也同时生成，需要修改allocproc()实现。
  - 进程切换时，页表也同时切换，需要修改scheduler()实现。scheduler()是进程的调度函数，切换进程之后，需要更新SATP寄存器，SATP寄存器存储着页表起始位置的物理地址。最后还要刷新TLB。
  - 进程释放时，页表和内核栈也同时释放，需要修改freeproc()。只需要释放三级内核页表，不需要释放物理内存，物理内存在用户页表的释放中已经被释放过了。
  - 至此，实现了各进程独享内核页表。
- ### `任务3 重新建立映射 简化copyin/copyinstr`
  - 分析：该任务将在内核页表内建立用户空间的映射，在每一个涉及添加/修改/删除用户页表映射的地方都需要进行修改。
  - 首先编写复制映射的函数uvmcopy_u2k()，相比uvmcopy()，uvmcopy_u2k()不需要分配新的物理地址。
  - fork(), exec(), sbrk()三个函数中都涉及到用户映射的改变，因此在这三个函数中都需要使用uvmcopy_u2k()。
  - 第一个进程的创建由userinit()执行，其中并未设计以上三个函数，因此还需要在userinit()里手动进行映射，确保第一个进程的内核页表也能正确访问用户数据。
  - 当虚拟页表内存在用户数据映射时候，便能直接使用解引用访问虚拟地址了，硬件会自动将通过三级页表将虚拟地址转化为物理地址。
  
- ### `完成！`
![Image text]
