# lab6 : Copy-on-Write Fork for xv6
### 开始日期：2023.01.18
### 完成日期：2023.01.19
- ### `心得`
  - copy-on-write (COW) 的作用是当通过fork()创建子进程的时候，不会立刻为子进程分配新的物理内存，而是让子进程的页表指向父进程的物理地址，子进程将于父进程共享物理内存，这些共享的内存会被标记为不可读。因此子进程或父进程试图写入共享的物理内存时，会触发page fault，这时应当将该物理内存进行复制并建立新的映射（设置为可读）。
  - COW使得父子进程的部分内存实现共享，从而节约物理内存。
- ### `任务 实现COW`
  - uvmpcopy()
    - uvmpcopy会在fork()时为子进程复制父进程的页表和物理内存，为了实现COW首先需要修改uvmpcopy的内存分配方式。
    - 删除物理内存的分配，直接把子进程的新页表映射到父进程的物理内存，并且分别将父子进程的页表的所有项目都设置为PTE_W。
    - 为了方便识别cow内存，需要将第8为PTE定义为PTE_COW，此处父子进程的页表项的PTE_COW都要设置为1。
    - 最后，所有被映射的物理内存的引用计数加一。
  - usertrap()
    - 子进程或父进程访问cow内存时由于没有写权限，会发生page fault。我们需要在usertrap中识别并处理由cow内存导致的page fault。
    - usertrap需要检查scause(13或15)和PTE_COW位是否同时符合要求，满足条件则进行后续操作。(假设子进程试图写入父进程的物理内存)
    - 创建一片新物理内存并将父进程的物理内存复制到里面，取消子进程对父进程物理内存的映射，以免发生remap，为新物理内存建立映射。
    - 最后，该片内存的引用计数减一，该操作将在kfree中完成。
  - 引用计数
    - 父子进程可能会一起共享同一片内存，对于这部分的内存需要使用引用计数，防止物理内存被删除后另一个进程无法访问的问题。
    - 在kalloc.c中声明了一个全局数组，数组长度为（PHYSTOP-KERNBASE）/ PGSIZE，物理地址除以4096即数组的索引，对应的值就是该物理地址的引用计数。
    - kfree()在释放物理内存前需要对引用计数减一，若此时引用计数等于0则释放物理内存，大于0则不释放内存。
    - kalloc()在分配物理内存时需要把引用计数初始化为1。
    - kinit()初始化物理内存时会对每片内存调用kfree，kfree中会将引用计数减一然后检测是否为0，即在进入kfree前只有引用计数为1的内存才会被初始化，因此kinit()需要设置每片内存的引用计数为1。
  - 锁
    - 所有涉及到修改引用计数的地方都需要加锁，防止进程切换导致引用计数的更新错误。
  - 坑
    - 在usertrap中取消子进程对父进程内存的映射时，必须通过 *pte &= ~PTE_V，不能使用 *pte = 0。
    - 原因暂时未知，等待后续补充。
- ### `完成！`
![Image text](https://raw.githubusercontent.com/JennyTurtles/MIT6.S081-2020-labs/cow/user/lab6完成.png)
