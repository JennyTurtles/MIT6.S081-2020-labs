# lab4:Traps
### 开始日期：2023.01.05
### 完成日期：2023.01.06

- ### `心得`
- Trap过程梳理：
  - ![Image text](https://raw.githubusercontent.com/JennyTurtles/MIT6.S081-2020-labs/traps/user/Trap.png)

- ### `任务1 回溯` 
  - 编写backtrace()，backtrace()将获取当前栈的栈顶指针，通过读取栈中内容得到函数的调用过程。
  - 栈从高地址开始向低地址增长，sp（Stack Frame）指向栈结构（Stack Frame）的底部，fp（Frame Pointer）指向栈结构的顶部，这里的栈结构不是栈，可以把它当作栈内存放的元素。
  - 栈结构从上到下依次是：返回地址（RA）,上个栈结构的fp，寄存器，本地变量，前两个项各占8个字节（这两个项各保存一个地址，地址空间为64位）。
  - 因此，已知一个栈结构的fp（指向顶部），fp-8即为栈的返回地址，fp-16即为上一个栈结构的fp，前者即需要输出的数据，后者为调用当前函数的函数栈地址，需要进入该地址进一步递归。
  - 用户栈会占用一个页，所有栈结构的地址都在当前页内，分别使用PGROUNDDOWN和PGROUNDUP即可得到页的下界和上界，即递归的边界条件。
- ### `任务2 定期警报` 
  - 实现一个定期的报警器，每隔一定时钟周期就运行报警函数，打印"alarm！"。
  - 分析：时钟周期的统计需要在内核中进行，而报警函数在用户空间，因此需要修改内核返回用户空间的目的地。从用户空间进入内核后，会将当前运行的位置（返回地址）存放在寄存器SEPC内，内核运行完trap代码后读取SEPC返回用户空间，因此只要将寄存器SEPC的值修改为报警函数，就可以直接在trap结束后进入报警函数。
  - 报警函数在执行的过程中会修改寄存器，这会导致原用户空间的函数执行出错，因此运行完报警函数必须返回内核恢复原寄存器内的值。具体实现：trap内修改SEPC之前把trapframe进行备份，保存在proc里面，直到报警函数运行结束，恢复备份里的trapframe。

- ### `完成！`
![Image text](https://raw.githubusercontent.com/JennyTurtles/MIT6.S081-2020-labs/traps/user/lab4.png)
