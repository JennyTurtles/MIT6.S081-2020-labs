# Lab7 : Multithreading
### 开始日期：2023.01.28
### 完成日期：2023.01.29
- ### `心得`
  - 为了实现处理器的多路复用，CPU需要频繁地进行线程的切换。线程切换的过程可以简单地概括为：旧进程从用户空间切换到内核，将寄存器的数据保存到p->context内(线程的context中)，并让调度器线程的寄存器加载到当前寄存器中；调度器线程将自己的寄存器保存到c->context(CPU的context)，然后把新线程的寄存器加载到当前寄存器，从而完成了线程的切换。
  - 不难发现，实现多线程的关键在于寄存器数据的变换。
- ### `实现用户级线程系统上下文切换`
  - 本实验将为用户级线程系统设计上下文切换机制，由于去掉了边界条件的判断，因此不再需要调度器线程作为中介，整个线程切换的过程得到了很大的简化。
  - struct thread
    - 添加所有的callee-save寄存器。caller-save寄存器都会被保存在线程的堆栈上，在新线程上下文恢复时可以直接从新线程的堆栈上恢复。而callee-save寄存器是由被调用函数（即thread_switch）保存的，在函数返回时这些数据会丢失，因此需要额外保存这些寄存器的内容。
    - 添加sp和ra。
  - thread_create()
    - thread_create()接受线程函数的地址，该地址需要被保存在thread结构体的ra里面。
    - sp是栈顶指针，在这里要被初始化为t->stack + STACK_SIZE。
  - thread_schedule()
    - 找到RUNNABLE线程后调用thread_switch()，将当前线程寄存器保存到全局数组内，加载新线程的寄存器。
- ### `实现哈希表的并行编程`
  - 哈希表的桶内为链表结构，当多个线程同时对同一个链表进行写操作的时候，就会出现错误，导致数据缺失。
  - 找到链表写操作的代码insert()，对其进行加锁即可。
  - 链表的读操作不涉及链表的修改，因此不需要加锁。
- ### `屏障`
  - 所有线程到达屏障时必须在此等待，直到所有其他线程也达到该点。
  - 为了实现此功能需要使用睡眠锁，最后一个线程到达屏障后唤醒其他线程。
  - 睡眠锁用到了条件变量，为了保证多线程修改条件变量的正确性，必须加上互斥锁，使得条件变量的修改操作在互斥锁锁定的临界区内。
- ### `完成！`
![Image text]()
